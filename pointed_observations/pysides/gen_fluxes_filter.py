from time import time
import numpy as np
import pandas as pd
import pickle

from astropy.cosmology import Planck15 as cosmo

from IPython import embed #for debug only!

def gen_fluxes_filter(cat, params): 

    tstart = time()

    print('Compute the flux of each galaxy in a set of filters using pre-computed grids...')

    if (not ("LIR" in cat.columns)) or (not ("Umean" in cat.columns)):
        print('The catalog must have been processed with gen_fluxes first (even with lambda_list = []) before running gen_fluxes_filter (it needs LIR and Umean columns generated by the first routine).')
        return False
    
    grid_filter_path = params['grid_filter_path']
    filter_list = params['filter_list']

    first_grid = True
    
    for filter_name in filter_list:

        filename = grid_filter_path+filter_name+'.p'

        print('Load the grid for the '+filter_name+' filter ('+filename+')...' )

        filter_grid_dict = pickle.load(open(filename, 'rb'))

        if first_grid == True:

            ref_filter_grid_dict = filter_grid_dict

        if first_grid == False:

            same_dU = (filter_grid_dict['dU'] == ref_filter_grid_dict['dU'])
            same_dlog1plusz = (filter_grid_dict['dlog1plusz'] == ref_filter_grid_dict['dlog1plusz'])
            same_Nlog1plusz = (filter_grid_dict['Nlog1plusz'] == ref_filter_grid_dict['Nlog1plusz'])
            same_NUmean = (len(filter_grid_dict['Umean']) == len(ref_filter_grid_dict['Umean']))

        #check if the grid is the same as the first file to avoid to have to recompute the indexes, always true for the reference file, not true for the other one
        if first_grid == True or not (same_dU and same_dlog1plusz and same_Nlog1plusz and same_NUmean):

            print('Compute the index and weight to perform a fast interpolation... If it is ran several times, it means that the grids are not all the same, which is not optimal because indexes and weights for the interpolation have to be recomputed each time.')

            #Compute the index for U
            
            Uindex = np.int_(np.array(np.round(cat['Umean'] / filter_grid_dict['dU']-1))) #the -1 one is because the grid starts with Umean = dU

            #Solve rare cases with too low of too high z
            lowUmean = np.where(Uindex < 0)
            if np.size(lowUmean) > 0:
                print('WARNING!!!!!', np.size(lowUmean), ' objects have a Umean below the lowest value of the grid. They were set by default to this lowest value.')
                Uindex[lowUmean[0]] = 0

            highUmean = np.where(Uindex >= len(filter_grid_dict['Umean']))
            if np.size(highUmean) > 0:
                print('WARNING!!!!!', np.size(highUmean), ' objects have a Umean above the highest value of the grid. They were set by default to this highest value.')
                Uindex[highUmean[0]] = len(filter_grid_dict['Umean'])-1


            #Compute the index for z and the weight for the interpolation

            log1pluszgrid = filter_grid_dict['dlog1plusz']*(np.arange(1,filter_grid_dict['Nlog1plusz']+1))
            z_grid = 10.**log1pluszgrid-1
            zindex_float = np.array((np.log10(1 + cat['redshift']) / filter_grid_dict['dlog1plusz']) - 1) # indexes starts at log(1+z) = dlog(1+z)
            zindex_below = np.int_(np.floor( zindex_float ))
            zindex_above = np.int_(np.ceil( zindex_float ))
            #weight to apply for the interpolation (weight to the flux of the immediatly inferior and superior grid element)
            weight_below = ( z_grid[zindex_above]-cat['redshift']) / ( z_grid[zindex_above]- z_grid[zindex_below])
            weight_above = (cat['redshift']- z_grid[zindex_below]) / ( z_grid[zindex_above]- z_grid[zindex_below])

            #If a point is exactly on the grid the weight formula does not work
            ongrid =  np.where(zindex_below == zindex_above)
            if np.size(ongrid) > 0:
                weight_above[ongrid[0]] = 0.5
                weight_below[ongrid[0]] = 0.5

            #Solve rare cases with too low or too high z
            toohighz = np.where(zindex_above >= filter_grid_dict['Nlog1plusz'])
            if np.size(toohighz) > 0:
                print('WARNING!!!!! A source is at higher z than the highest z of the grid. Use the value of this last element.')
                zindex_above[toohighz[0]] = filter_grid_dict['Nlog1plusz']-1
                zindex_below[toohighz[0]] = filter_grid_dict['Nlog1plusz']-1
                weight_above[toohighz[0]] = 0
                weight_below[toohighz[0]] = 1

            toolowz = np.where(zindex_below < 0)
            if np.size(toolowz) > 0:
                print('WARNING!!!!! A source is at lower z than the lower z of the grid. Use a rescaling in (zmin_grid/z)^2 for the interpolation weight. It should be an excellent approximation.')
                zindex_above[toolowz[0]] = 0
                zindex_below[toolowz[0]] = 0
                weight_above[toolowz[0]] = (z_grid[0]/cat['redshift'][toolowz[0]])**2
                weight_below[toolowz[0]] = 0

        first_grid = False

        S_LIR_filter = np.zeros(len(cat)) #grid of flux before multiplying by LIR

        print('Compute the fluxes for the MS templates...')
        
        MSindex = np.where((cat['issb'] == False) & (cat['qflag'] == False))[0]

        S_LIR_filter[MSindex] = filter_grid_dict['Snu_LIR_MS'][zindex_below[MSindex], Uindex[MSindex]] * weight_below[MSindex] + \
            filter_grid_dict['Snu_LIR_MS'][zindex_above[MSindex], Uindex[MSindex]] * weight_above[MSindex]

        print('Compute the fluxes for the SB templates...')
                
        SBindex = np.where(cat['issb'] == True)[0]

        S_LIR_filter[SBindex] = filter_grid_dict['Snu_LIR_SB'][zindex_below[SBindex], Uindex[SBindex]] * weight_below[SBindex] + \
            filter_grid_dict['Snu_LIR_SB'][zindex_above[SBindex], Uindex[SBindex]] * weight_above[SBindex]

        kwargs = {'S'+filter_name : S_LIR_filter * cat['LIR'] * cat['mu']}
        cat = cat.assign(**kwargs)
        
    tstop = time()

    print('Fluxes through filters of ', len(cat), ' galaxies generated in ', tstop-tstart, 's')

    return cat
